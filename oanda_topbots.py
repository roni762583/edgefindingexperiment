# -*- coding: utf-8 -*-
"""Oanda_TopBots.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uta2PVCTAdX1cL2Yd46xFxFOcKmlIX5c
"""

# pull price candles from Oanda, Calc. TopBots S/R, other features for M/L prediction

import requests
import json
import numpy as np
import pandas as pd
import time
import pytz
from datetime import datetime

def json_to_pandas(json):
    json_file = json.json()
    price_json = json_file["candles"]
    times = []
    close_price, high_price, low_price, open_price = [], [], [], []
    #print(json_file)
    for candle in price_json:
        times.append(candle["time"])
        close_price.append(float(candle["mid"]["c"]))
        high_price.append(float(candle["mid"]["h"]))
        low_price.append(float(candle["mid"]["l"]))
        open_price.append(float(candle["mid"]["o"]))
    dataframe = pd.DataFrame({"close": close_price, "high": high_price, "low": low_price, "open": open_price})
    dataframe.index = pd.to_datetime(times)
    return dataframe


# STREAM_API = "stream-fxtrade.oanda.com"
ACCESS_TOKEN = 'ca4d79791f1fccaa6b240b217eaee1ce-03942c5628841ee87bf740df508cc7c7'
ACCOUNT_ID = '001-001-1967491-002'

INSTRUMENT = "EUR_USD"
API = "api-fxtrade.oanda.com"
CANDLES_PATH = f"/v3/accounts/{ACCOUNT_ID}/instruments/{INSTRUMENT}/candles"

from_time = time.mktime(pd.to_datetime("01/01/2020").timetuple())
to_time = time.mktime(pd.to_datetime("02/10/2021").timetuple())
print(f"Window start: {from_time}, window end: {to_time}." )

header = {"Authorization": "Bearer "+ACCESS_TOKEN}
queryHour = {"from": str(from_time), "to": str(to_time), "granularity":"H2"}

response2 = requests.get("https://"+API+CANDLES_PATH, headers=header, params=queryHour)
# make pd df from json
Candles_H_df = json_to_pandas(response2)

# start analysind Candles_H_df and get ready to feed into NN predict High, and Low of next hourly bar
# part 1 of top bots

# get price inflection locations X 1/hours ago

# Get GMT current time (at time of running)
tz = pytz.timezone('Europe/London')
london_current_datetime = datetime.now(tz)
# a = tz.fromutc(datetime.utcfromtimestamp(datetime.now()).replace(tzinfo=tz))
# print ('a= ', a)

inflections = list()
inflection = ''
n = 0
c = 0
for indx in Candles_H_df.index:
  if (n<=2):
    n+=1
    continue
  h2 = Candles_H_df['high'][n-2] # starts at index 0
  h1 = Candles_H_df['high'][n-1]
  h = Candles_H_df['high'][n]

  l2 = Candles_H_df['low'][n-2] # starts at index 0
  l1 = Candles_H_df['low'][n-1]
  l = Candles_H_df['low'][n]

  if(h1>h and h1>h2):
    #print(inflections[-1])
    #if(inflections[-1][1] == 'H' and inflections[-1][2]<h1): # fix this to only record highest high in consecutive 'H's
    inflection = 'H'

  if(l1<l and l1<l2):
    if not inflection:
      inflection = 'L'
    else:
      # supposed to ensure inflections alternate 'H' and 'L'
      inflection = 'H' if (inflections[-1][1] == 'L') else 'L'
      #c+=1
      #print(c) # it works 68 times

  price = Candles_H_df['high'][n-1] if(inflection=='H') else Candles_H_df['low'][n-1]
  if inflection:
    idx = Candles_H_df.index[n]+pd.DateOffset(hours=-1)

    timeAgoSec = (london_current_datetime - idx.replace(tzinfo=tz)).total_seconds()
    timeAgoHours = divmod(timeAgoSec, 3600)[0]
    #print('1/time ago: ', 1.0/timeAgoHours)

    inflections.append( (idx ,inflection,price, 1.0/timeAgoHours) ) #time index is 1 hr ahead
    #print(Candles_H_df.index[n])
    #print(Candles_H_df.index[n]+pd.DateOffset(hours=-1))
    #print(indx, inflection, price)

  n+=1
  inflection = ''

# part 2 - clean up repeating inflections
inflectionsToDelete = list()
for i in range(1,len(inflections)-1):
  #print (i, '   ', inflections[i][1])
  if(inflections[i][1] ==  inflections[i-1][1]): #if repeating inflection found, get rid of consecitive 'L's
    #print (i, inflections[i][1], inflections[i-1][1])
    if(inflections[i][1] == 'L'):
      #print (type(inflections[i][2]))
      if(inflections[i][2] > inflections[i-1][2]): # if new inflection is lower low, choose it instead of prev. inflection
        #print (i, inflections[i][1], inflections[i-1][1])
        inflectionsToDelete.append(inflections[i])

    # get rid of consecitive 'H's
    if(inflections[i][1] == 'H'):

      if(inflections[i][2] < inflections[i-1][2]): # if new inflection is higher high, choose it instead of prev. inflection
        inflectionsToDelete.append(inflections[i])
# some repeating inflections, but many have been removed, this can be further debugged later
print('len(inflections) = ', len(inflections))
inflections = [x for x in inflections if x not in inflectionsToDelete]
print('len(inflections) after delete ', len(inflections))
Candles_H_df["close"].plot()
print(len(Candles_H_df))

# histogram of inflection points
from scipy.stats import *
import pylab as p
import matplotlib.pyplot as plt

inflections_df = pd.DataFrame(inflections, columns=['date', 'inflection','price','hoursAgoInverse'])
# print(pdf.head())

mini = inflections_df['price'].min()
maxi = inflections_df['price'].max()
delta = maxi - mini
#print('pip range: ',delta*10000) # number of pips in range
pips = delta*10000
ppb = 10 # int(Candles_H_df['atr'][-1] *1000) # pips per bin, bin width
b = int(pips/ppb)
# plot histogram
# ax = inflections_df['price'].plot.hist(bins=b, alpha=0.5)
# for bin in range(min, max)
#print(inflections_df.tail())
#print('pips per bin: ', ppb)
print('skew: ',skew(inflections_df['price']))
print('kurtosis: ', kurtosis(inflections_df['price']))
print('No. bins: ',b)
#cut = pd.cut(inflections_df['price'], bins=b).value_counts() # does binning
# print(pd.unique(pd.cut(inflections_df['price'], bins=b).value_counts()) )# max is highest number of inflection per bin
#cut.plot()
#print(cut)

#print((cut.index))
#sum = inflections_df[inflections_df['price'] >= cut[0][0] and inflections_df['price'] < cut[0][1]]['hoursAgoInverse'].sum()
print ('______________________________________________________________________')

hist, bin_edges = np.histogram(inflections_df['price'], bins=b)

#print('len(hist) ', len(hist))
#print ('len(bin_edges) ', len(bin_edges))

_ = plt.hist(inflections_df['price'], bins=b)

bins = list()
left_edge = 0.0
# loop over bin edges
for i in range(1,len(bin_edges)):
  mask = (inflections_df['price'] >= bin_edges[i-1]) & (inflections_df['price'] < bin_edges[i])
  binSum = inflections_df['hoursAgoInverse'][mask].sum()
  # add to list: bin (left) edge, sum(hoursAgoInverse), count in bin
  bins.append((bin_edges[i], binSum)) # , hist[i+1]))
  #print(binSum)
  # set left edge
  #left_edge = bin_edges[i]
#print(bins)
print(bins)
print("should normalize data")

prices = [x[0] for x in bins]
sr = [x[1] for x in bins]
plt.plot(prices, sr)
print(sr)
# displaying the title
plt.title("Tops Bots S/R - sum inverse hours since inflection")
plt.show()

# change x y
prices = [x[0] for x in bins]
sr = [x[1] for x in bins]
plt.plot(sr, prices)
# displaying the title
plt.title("Tops Bots S/R - sum inverse hours since inflection")
plt.show()

